#define NO_DATA -10000/* index     239,0           -10000,1           1.95033e+06,2 accelx    -1.25301,3 accely    9.66265,4 accelz    52.6506,5           -10000,6           -10000,7           -10000,8           -10000,9           -10000,10          -10000,11          2.56489,12          1.20611,13          1.13545,14          0.0418182,15          -0.937273,16          0,17          -10000,18          -10000,19          2543.93,20          2.76375e+19,21          4.59163e-41,22          0,23          0,24          -10000,25          -10000,26          -10000*/class ShimmerData{private:	double data[SHIMMER_NUM_ARGS+1];    float quaternion[4];    float orientationMatrix[3];	double getAccelMax(){ return G_FORCE * 2.5; };	double getAccelMin(){ return G_FORCE * -2.5; };public:    enum DataIndices { INDEX=0, TIME_STAMP=1, ACCELX=2, ACCELY=3, ACCELZ=4, GYROX=11, GYROY=12, GYROZ=13, QX=20, QY=21, QZ=22, QA=23 };    	void scaleAccel()	//scale to 0 - 1	{		//TODO: fix, depend on shimmer info not hard-coded//		for (int i = 1; i < 10; i++)//		{		//			data[i] = (data[i] - getAccelMin()) / (getAccelMax() - getAccelMin());//		}//0-1 direction                for (int i = 1; i < 10; i++)		{			data[i] =  std::abs(data[i] )  / ( getAccelMax() );		}//0-1 no direction...	};	std::string str()	{		std::stringstream ss;		for (int i = 0; i < SHIMMER_NUM_ARGS; i++)		{			ss << data[i];			if (i < SHIMMER_NUM_ARGS - 1) ss << ",";		}		ss << std::endl;		return ss.str();	};	inline double getTimeStamp(){ return data[1]; };	inline ci::Vec3d getAccelData()	{		ci::Vec3d accelData(data[2], data[3], data[4]);		return accelData;	};    inline void setAccelData(ci::Vec3d d)    {        data[2] = d.x;        data[3] = d.y;        data[4] = d.z;    };	inline ci::Vec3d getAccelDataLowNoise()	{		ci::Vec3d accelData(data[5], data[6], data[7]);		return accelData;	};	inline ci::Vec3d getAccelDataWideRange()	{		ci::Vec3d accelData(data[8], data[9], data[10]);		return accelData;	};	inline ci::Vec3d getGyro()	{		ci::Vec3d gyro(data[11], data[12], data[13]);		return gyro;	};    inline void setGyro(ci::Vec3d d)    {        data[11] = d.x;        data[12] = d.y;        data[13] = d.z;    };	inline ci::Vec3d getMagnet()	{		ci::Vec3d mag(data[14], data[16], data[16]);		return mag;	};	inline double getBatt1(){ return data[17]; };	inline double getBatt2(){ return data[18]; };    inline double getCameraTimeStamp(){ return data[19]; };	inline void setData(int index, double d)	{		data[index] = d;	}	inline double getData(int index)	{        if(index < 20)        {            return data[index];        }        else if (index < 24)        {            int i = index - 20;            return getQuarternion(i);        }        else        {            std::cout << "Warning! ShimmerData: Out of Range! Index: " << index << "\n";            return NO_DATA;         }			}    inline float getQuarternion(int index)    {        assert( index < 4 && index >= 0 );        return quaternion[index];    };        inline ci::Vec4d getQuarternionVec4d()    {       return ci::Vec4d(quaternion[0], quaternion[1], quaternion[2], quaternion[3]);    };        inline void setQuarternion(ci::Vec4d quat)    {        quaternion[0]=quat[0];        quaternion[1]=quat[1];        quaternion[2]=quat[2];        quaternion[3]=quat[3];    };        inline void setQuarternion(float x, float y, float z, float angle)    {        quaternion[0] = x;        quaternion[1] = y;        quaternion[2] = z;        quaternion[3] = angle;    };        inline float getOrientationMatrix(int index)    {        assert( index < 3 && index >= 0 );        return orientationMatrix[index];    };        inline void setOrientationMatrix(float azimuth, float pitch, float roll)    {        orientationMatrix[0] = azimuth;        orientationMatrix[1] = pitch;        orientationMatrix[2] = roll;    };    	ShimmerData()    {        //init memory        for(int i=0; i<19; i++)        {            data[i] = NO_DATA;        }                for(int i=0; i<4; i++)            quaternion[i] = NO_DATA;                for(int i=0; i<3; i++ )            orientationMatrix[i] = NO_DATA;    }};